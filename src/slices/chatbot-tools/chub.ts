import type { JsonString } from "../../lib/json";
import { filterOutUndefined } from "../../lib/object";
import type { CharacterBook, TavernCardV2 } from "./types";

const CHUB_PAGE_SIZE = 40;
const BASE_URL = "https://gateway.chub.ai";
const API_URL = `${BASE_URL}/api`;

// TODO: Temporary workaround. Should be user configurable, however this should stay
// to be able to revert to this as the default.
export const CHUB_TAGS_TO_HIDE = ["ROOT", "TAVERN", "OAI", "GPT4"];

export type UUID = string & {
  readonly __type: "UUID";
};

export interface ChubPageRaw<T> {
  readonly count: number;
  readonly nodes: readonly T[];
  readonly page: number;
  readonly previous_cursor: string | null;
  readonly cursor: string | null;
}

// FIXME: is it actually possible to detect search results count?
export type ChubPage<T> = ChubPageRaw<T> & {
  readonly pageCount: number;
};

export type ChubUserId = number & {
  readonly __type: "ChubUserId";
};

export type ChubUsername = string & {
  readonly __type: "ChubUsername";
};

export interface ChubSelfUser {
  readonly id: ChubUserId;
  /** Autogenerated username */
  readonly name: ChubUsername;
  readonly user_name: string;
  readonly avatar_url: string;
  readonly subscription: number;
  readonly is_admin: boolean;
  readonly is_mod: boolean;
  readonly is_verified: boolean;
  readonly no_nsfw: boolean;
  readonly no_nsfl: boolean;
  readonly alpha_user: boolean;
  readonly trial_remaining: number;
  readonly verified_age: boolean;
}

// TODO: Define the `ChubModel` type properly when more information is available.
export interface ChubModel {}

export interface ChubUser {
  readonly id: ChubUserId;
  readonly avatarUrl: string;
  /** Username */
  readonly username: string;
  /** Persona name */
  readonly name: string;
  readonly first_name: string;
  readonly last_name: string;
  readonly public_email: string | null;
  readonly projects: ChubPageRaw<ChubCardRaw>;
  readonly bio: string | null;
  readonly discord: string | null;
  readonly agnai_id: string | null;
  readonly avatar_url: string;
  readonly models: ChubPageRaw<ChubModel>;
  readonly n_followees: number;
  readonly n_followers: number;
  /** Whether the user follows you */
  readonly user_follows: boolean;
  /** Whether you follow the user */
  readonly follows_user: boolean;
  readonly user_blocks: boolean;
  readonly badges: readonly unknown[];
}

export type ChubCardId = number & {
  readonly __type: "ChubCardId";
};

export type ChubCardFullPath = string & {
  readonly __type: "ChubCardFullPath";
};

export interface ChubTokenCounts {
  readonly description: number;
  readonly personality: number;
  readonly scenario: number;
  readonly mes_example: number;
  readonly first_mes: number;
  readonly system_prompt: number;
  readonly post_history_instructions: number;
  readonly total: number;
}

export type ChubLabel = {
  readonly title: "TOKEN_COUNTS";
  readonly description: JsonString<ChubTokenCounts>;
};

export interface ChubExtension {
  readonly id: ChubCardId;
  readonly preset: string | null;
  readonly full_path: ChubCardFullPath;
  readonly extensions: unknown[];
  readonly expressions: unknown | null;
  readonly alt_expressions: Record<string, unknown>;
  readonly background_image: string;
  readonly related_lorebooks: unknown[];
}

export interface DepthPrompt {
  readonly depth: number;
  readonly prompt: string;
}

export interface ChubCardExtensions {
  readonly chub: ChubExtension;
  readonly depth_prompt: DepthPrompt;
}

export interface ChubCardDefinition {
  readonly id: number;
  readonly is_public: boolean;
  readonly full_path: string;
  readonly avatar: string;
  readonly project_name: string;
  readonly nsfw_image: boolean;
  readonly name: string;
  readonly description: string;
  readonly example_dialogs: string;
  readonly first_message: string;
  readonly personality: string;
  readonly scenario: string;
  readonly system_prompt: string;
  readonly post_history_instructions: string;
  readonly tavern_personality: string;
  readonly alternate_greetings: readonly string[];
  readonly embedded_lorebook: CharacterBook | null;
  readonly extensions: ChubCardExtensions;
  readonly bound_preset: string | null;
  readonly is_owner: boolean;
  readonly voice_id: string | null;
  readonly voice: unknown | null;
}

export interface ChubCard<Full extends boolean = boolean> {
  readonly id: ChubCardId;
  readonly name: string;
  readonly fullPath: ChubCardFullPath;
  readonly description: string;
  readonly starCount: number;
  readonly lastActivityAt: Date;
  readonly createdAt: Date;
  readonly labels: readonly ChubLabel[];
  readonly topics: readonly string[];
  readonly forksCount: number;
  readonly rating: number;
  readonly ratingCount: number;
  readonly projectSpace: "characters" | "lorebooks";
  /** -1 for anonymous */
  readonly creatorId: number;
  readonly nTokens: number;
  readonly tagline: string;
  readonly primaryFormat: "tavern";
  readonly related_characters: readonly number[];
  readonly related_lorebooks: readonly number[];
  readonly related_prompts: readonly number[];
  readonly related_extensions: readonly number[];
  readonly hasGallery: boolean;
  readonly nChats: number;
  readonly nMessages: number;
  readonly definition: Full extends true ? ChubCardDefinition : null;
  readonly permissions: "read" | "write" | "admin";
  readonly is_public: boolean;
  readonly is_favorite: boolean;
  readonly nsfw_image: boolean;
  readonly n_public_chats: number;
  readonly n_favorites: number;
  readonly is_unlisted: boolean;
  readonly avatar_url: string;
  readonly max_res_url: string;
  readonly bound_preset: string | null;
  readonly project_uuid: string | null;
  readonly voice_id: string | null;
  readonly verified: boolean;
  readonly recommended: boolean;
  readonly ratings_disabled: boolean;
  readonly lang_id: number;
  readonly badges: readonly string[];
}

interface ChubCardRaw<Full extends boolean = boolean>
  extends Omit<ChubCard<Full>, "lastActivityAt" | "createdAt"> {
  readonly lastActivityAt: string;
  readonly createdAt: string;
}

export function chubCardRawToChubCard(card: ChubCardRaw): ChubCard {
  return {
    ...card,
    lastActivityAt: new Date(card.lastActivityAt),
    createdAt: new Date(card.createdAt),
  };
}

export function chubPageRawToChubPage<T>(page: ChubPageRaw<T>): ChubPage<T> {
  return { ...page, pageCount: Math.ceil(page.nodes.length / CHUB_PAGE_SIZE) };
}

export async function chubListSimilarCards(
  id: number,
): Promise<readonly ChubCard[]> {
  const response = await fetch(`${API_URL}/projects/similar/${id}/true/true`);
  const data: ChubPageRaw<ChubCardRaw> = await response.json();
  return data.nodes.map(chubCardRawToChubCard);
}

export interface ChubListForksOptions {
  readonly nsfw?: boolean;
  readonly nsfl?: boolean;
}

// https://gateway.chub.ai/forks/project/4700696?limit=20&nsfw=true&nsfl=true
export async function chubListForks(
  id: number,
  options: ChubListForksOptions = {},
): Promise<readonly ChubCard[]> {
  const params = new URLSearchParams(
    filterOutUndefined({
      limit: CHUB_PAGE_SIZE.toString(),
      nsfw: options.nsfw ? "true" : undefined,
      nsfl: options.nsfl ? "true" : undefined,
    }) as Record<string, string>,
  ).toString();
  const response = await fetch(`${BASE_URL}/forks/project/${id}?${params}`);
  const data: ChubPageRaw<ChubCardRaw> = await response.json();
  return data.nodes.map(chubCardRawToChubCard);
}

interface ChubGetCardResponse {
  readonly errors: readonly unknown[] | null;
  readonly node: ChubCardRaw;
  readonly nodes: Record<`${bigint}`, ChubCardRaw>;
  readonly permissions: "read";
  readonly is_favorite: boolean;
}

export function isProbablyChubCardFullPath(
  fullPath: unknown,
): fullPath is ChubCardFullPath {
  return typeof fullPath === "string" && /^[^/]+[/][^/]+$/.test(fullPath);
}

export async function chubGetCardByFullPath<Full extends boolean = false>(
  fullPath: ChubCardFullPath,
  options: ChubGetCardOptions<Full> = {},
): Promise<ChubCard<Full>> {
  const params = new URLSearchParams(
    filterOutUndefined({
      full: options.full ? "true" : undefined,
    }) as Record<string, string>,
  ).toString();
  const response = await fetch(`${API_URL}/characters/${fullPath}?${params}`);
  const data: ChubGetCardResponse = await response.json();
  return chubCardRawToChubCard(data.node);
}

export function isProbablyChubCardId(id: unknown): id is ChubCardId {
  return typeof id === "number" && Number.isInteger(id) && id > 0;
}

export async function chubGetCardById<Full extends boolean = false>(
  id: ChubCardId,
  options: ChubGetCardOptions<Full> = {},
): Promise<ChubCard<Full>> {
  const params = new URLSearchParams(
    filterOutUndefined({
      full: options.full ? "true" : undefined,
    }) as Record<string, string>,
  ).toString();
  const response = await fetch(`${API_URL}/characters/${id}?${params}`);
  const data: ChubGetCardResponse = await response.json();
  return chubCardRawToChubCard(data.node);
}

export interface ChubGetCardOptions<Full extends boolean = boolean> {
  readonly full?: Full;
}

export async function chubGetCard<Full extends boolean = false>(
  id: ChubCardId | ChubCardFullPath,
  options: ChubGetCardOptions<Full> = {},
): Promise<ChubCard<Full>> {
  if (isProbablyChubCardId(id)) {
    return await chubGetCardById(id, options);
  } else {
    return await chubGetCardByFullPath(id, options);
  }
}

export interface ChubSearchParams {
  readonly first?: number;
  readonly namespace?: "characters" | "lorebooks";
  readonly nsfw?: boolean;
  readonly nsfl?: boolean;
  readonly chub?: boolean;
  readonly count?: boolean;
  readonly topics?: string;
  readonly exclude_mine?: boolean;
  readonly include_forks?: boolean;
  readonly sort?: ChubSortType;
  readonly search?: string;
  readonly username?: string;
  readonly my_favorites?: boolean;
  readonly min_tokens?: number;
  readonly page?: number;
}

export const CHUB_SORT_NAMES = [
  "User Default",
  "Trending",
  "AI Rating",
  "Popularity",
  "Messages per Chat",
  "Chats per User",
  "Messages per User",
  "Random",
  "Rating",
  "Update Time",
  "Name",
  "# Tokens",
  "# Favorited",
  "Creation Time",
  "# Public Chats",
  "# Downloads",
] as const;
export type ChubSortName = (typeof CHUB_SORT_NAMES)[number];

export const CHUB_SORT_TYPES = [
  "default",
  "trending",
  "ai_rating",
  "star_count",
  "msgs_chat",
  "chats_user",
  "msgs_user",
  "random",
  "rating",
  "last_activity_at",
  "name",
  "n_tokens",
  "n_favorites",
  "created_at",
  "public_chats",
  "download_count",
] as const;
export type ChubSortType = (typeof CHUB_SORT_TYPES)[number];

export const CHUB_SORT_NAME_TO_TYPE = {
  "User Default": "default",
  Trending: "trending",
  "AI Rating": "ai_rating",
  Popularity: "star_count",
  "Messages per Chat": "msgs_chat",
  "Chats per User": "chats_user",
  "Messages per User": "msgs_user",
  Random: "random",
  Rating: "rating",
  "Update Time": "last_activity_at",
  Name: "name",
  "# Tokens": "n_tokens",
  "# Favorited": "n_favorites",
  "Creation Time": "created_at",
  "# Public Chats": "public_chats",
  "# Downloads": "download_count",
} satisfies Record<ChubSortName, ChubSortType>;

export async function chubSearchCards(
  params: ChubSearchParams,
): Promise<readonly ChubCard[]> {
  const query = new URLSearchParams(
    params as Record<string, string>,
  ).toString();
  const response = await fetch(`${BASE_URL}/search?${query}`);
  const data: { readonly data: ChubPageRaw<ChubCardRaw> } =
    await response.json();
  return data.data.nodes.map(chubCardRawToChubCard);
}

export type ChubTimelineParams = {
  readonly cursor?: string | undefined;
  readonly page?: number | undefined;
  readonly count?: boolean | undefined;
};

export async function chubGetTimelinePage(
  params: ChubTimelineParams = {},
): Promise<readonly ChubCard[]> {
  const query = new URLSearchParams(
    filterOutUndefined(params) as Record<string, string>,
  ).toString();
  const response = await fetch(`${API_URL}/timeline/v1?${query}`);
  const { data }: { readonly data: ChubPageRaw<ChubCardRaw> } =
    await response.json();
  return data.nodes.map(chubCardRawToChubCard);
}

export async function chubGetSelfUser(): Promise<ChubSelfUser> {
  const response = await fetch(`${API_URL}/self`);
  return await response.json();
}

export async function chubGetUserById(username: string): Promise<ChubUser> {
  const response = await fetch(`${API_URL}/users/${username}`);
  return await response.json();
}

export type ChubCardQuery =
  | { type: "timeline"; cursor?: string }
  | { type: "search"; params: ChubSearchParams; cursor?: string };

export type ChubCardQueryType = ChubCardQuery["type"];
export const CHUB_CARD_QUERY_TYPES = [
  "timeline",
  "search",
] as const satisfies readonly ChubCardQueryType[];

export async function chubGetCardsByQuery(
  query: ChubCardQuery,
): Promise<readonly ChubCard[]> {
  const widenedQuery = query;
  switch (query.type) {
    case "timeline":
      return await chubGetTimelinePage({ cursor: query.cursor });
    case "search":
      return await chubSearchCards(query.params);
    default:
      // oxlint-disable-next-line no-unused-expressions
      query satisfies never; // Ensure all cases are handled
      throw new Error(`Unsupported query type: ${widenedQuery.type}`);
  }
}

export type ChubFollow = {
  readonly user_id: ChubUserId;
  readonly avatar_url: string;
  readonly username: string;
};

export type ChubFollowsResponse = {
  readonly follows: readonly ChubFollow[];
  readonly tag_follows: readonly unknown[];
  readonly count: number;
  readonly tag_count: number;
  readonly page: number;
};

export type ChubGetFollowsParams = {
  readonly page?: number;
};

export async function chubGetFollowsByUsername(
  username: string,
  params: ChubGetFollowsParams = {},
): Promise<ChubFollowsResponse> {
  const query = new URLSearchParams({
    page: "1",
    ...params,
  } as Record<string, string>).toString();
  const response = await fetch(`${API_URL}/follows/${username}?${query}`);
  return await response.json();
}

export type ChubConfigEntry =
  | {
      readonly id: "theme";
      readonly sub_id: "Default";
      readonly value: {
        readonly mode?: "light" | "dark";
        readonly css_path?: string | null;
        readonly em_color?: string;
        readonly blur_nsfw?: boolean;
        readonly font_size?: string;
        readonly link_color?: string;
        readonly text_color?: string;
        readonly line_height?: string;
        readonly quote_color?: string;
        readonly use_sidebar?: boolean;
        readonly collapseable?: boolean;
        readonly card_font_size?: number;
        readonly show_background?: boolean;
        readonly show_custom_css?: boolean;
        readonly dark_header_color?: string;
        readonly quote_color_light?: string;
        readonly dark_submenu_color?: string;
        readonly light_header_color?: string;
        readonly light_submenu_color?: string;
        readonly chat_background_color?: string;
        readonly dark_background_color?: string;
        readonly light_background_color?: string;
        readonly message_background_color?: string;
        readonly chat_background_color_light?: string;
        readonly message_background_color_light?: string;
      };
    }
  | {
      readonly id: "use_legacy_ooba";
      readonly sub_id: "Default";
      readonly value: boolean;
    }
  | {
      readonly id: "open_ai_mode";
      readonly sub_id: "Default";
      readonly value: "api_key";
    }
  | {
      readonly id: "anthropic_mode";
      readonly sub_id: "Default";
      readonly value: "api_key";
    };

export interface ChubConfigUpdateRequest {
  readonly update: readonly ChubConfigEntry[];
}

export async function chubUpdateConfig(
  request: ChubConfigUpdateRequest,
): Promise<void> {
  const response = await fetch(`${API_URL}/config`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(request),
  });
  return await response.json();
}

export type ChubConfigKey =
  | "theme"
  | "openAIKey"
  | "anthropicKey"
  | "openRouterKey"
  | "palm2Key"
  | "naiKey"
  | "characterOverrides"
  | "elevenLabsKey"
  | "reverseProxyKey"
  | "open_ai_reverse_proxy"
  | "open_ai_mode"
  | "anthropic_mode"
  | "anthropicReverseProxyKey"
  | "characterDraft"
  | "anthropic_reverse_proxy"
  | "use_legacy_ooba"
  | "api_url"
  | "ooba_streaming_url";

export type ChubConfigFetchRequest<Keys extends ChubConfigKey = ChubConfigKey> =
  {
    /** Value is typically `["*"]`. */
    readonly to_fetch: Record<Keys, string[]>;
  };

export type ChubConfigValue = ChubConfigEntry extends infer T
  ? T extends { value: infer Value }
    ? Value
    : never
  : never;

export type ChubConfigFetchResponse<
  Keys extends ChubConfigKey = ChubConfigKey,
> = {
  readonly configs: {
    readonly [Key in Keys]: {
      readonly Default?: (ChubConfigEntry & { readonly id: Key })["value"];
    };
  };
};

export async function chubFetchConfig(
  request: ChubConfigFetchRequest,
): Promise<ChubConfigFetchResponse> {
  const response = await fetch(`${BASE_URL}/config/fetch`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(request),
  });
  return await response.json();
}

export async function chubFetchEntireConfig(): Promise<ChubConfigFetchResponse> {
  return await chubFetchConfig({
    to_fetch: {
      theme: ["*"],
      anthropic_mode: ["*"],
      anthropicReverseProxyKey: ["*"],
      open_ai_mode: ["*"],
      open_ai_reverse_proxy: ["*"],
      anthropic_reverse_proxy: ["*"],
      use_legacy_ooba: ["*"],
      api_url: ["*"],
      ooba_streaming_url: ["*"],
      openAIKey: ["*"],
      anthropicKey: ["*"],
      openRouterKey: ["*"],
      palm2Key: ["*"],
      naiKey: ["*"],
      elevenLabsKey: ["*"],
      reverseProxyKey: ["*"],
      characterOverrides: ["*"],
      characterDraft: ["*"],
    },
  });
}

interface ChubAccount {
  readonly id: string;
  readonly name: string;
  readonly user_name: string;
  readonly avatar_url: string;
  readonly subscription: number;
  readonly is_admin: boolean;
  readonly is_mod: boolean;
  readonly is_verified: boolean;
  readonly no_nsfw: boolean;
  readonly no_nsfl: boolean;
  readonly alpha_user: boolean;
  readonly trial_remaining: number;
  readonly verified_age: boolean;
  readonly about_me: string;
  readonly profile: string;
  readonly invite_key: string | null;
  readonly blocked_tags: unknown[];
  readonly blocked_users: unknown[];
  readonly blacklisted_words: unknown[];
  readonly badges: unknown[];
  readonly default_sort: "n_favorites" | "n_tokens" | "last_activity_at";
  readonly tokens: unknown[];
  readonly cancelled: boolean;
  readonly paused: boolean;
  readonly failed: boolean;
  readonly stripe: null | unknown; // Stripe data
  readonly referrer_id: string | null;
  readonly email: string | null;
  readonly subscription_expires: string | null; // ISO date string or null
  readonly will_cancel: boolean;
  readonly last_payment_method: null | unknown; // Payment method data
  readonly fraud_flag: boolean;
  readonly config: ChubApiConfig;
  readonly balance: number;
  readonly bluesky: null | unknown; // Bluesky data
  readonly preferred_language: string | null; // ISO language code or null
}

export interface ChubApiConfig {
  // `string & {}` is a trick to allow any string but still allow for auto-completion.
  readonly api: "mercury" | "mars" | (string & {});
  readonly open_ai_mode: "api_key";
  readonly model: string;
  readonly open_ai_reverse_proxy: string;
  readonly jailbreak_prompt: string;
  readonly post_history_instructions: string;
  readonly impersonate_prompt: string;
  readonly api_url: string;
  readonly use_pygmalion_format: boolean;
  readonly generation_settings: Record<string, unknown>;
  readonly immersive_mode: boolean;
  readonly use_lorebooks: boolean;
  readonly text_streaming: boolean;
  readonly use_version_two: boolean;
  readonly anthropic_mode: "api_key";
  readonly anthropic_reverse_proxy: string;
  readonly auto_summarization: boolean;
  readonly use_legacy_ooba: boolean;
  readonly ooba_streaming_url: string;
  readonly input_sequence: string;
  readonly output_sequence: string;
  readonly stop_sequence: string;
  readonly wrap_sequences: boolean;
  readonly include_names: boolean;
  readonly chat_separator: string;
  readonly assistant_prefill: string;
  readonly prompt_note: {
    readonly note: string;
    readonly depth: number;
  };
  readonly tts_api: "elevenlabs";
  readonly tts_model: string;
  readonly tts_voice: string;
  readonly auto_tts: boolean;
  readonly chub_tts: boolean;
  readonly narrate_quotes: boolean;
  readonly narrate_inside: boolean;
  readonly narrate_delimiter: string;
  readonly similarity_boost: number;
  readonly stability: number;
  readonly use_speaker_boost: boolean;
  readonly pitch: number;
  readonly rate: number;
  readonly ban_emoticons: boolean;
  readonly nrep_penalty: number;
  readonly nfreq_penalty: number;
  readonly nai_preamble: string;
  readonly nai_prefix: "vanilla";
  readonly nai_phrase_rep_pen: "off";
  readonly prompt_template: string | null; // Template for prompts
  readonly message_template: string | null; // Template for messages
}

export async function chubGetAccount(): Promise<ChubAccount> {
  const response = await fetch(`${API_URL}/account`);
  return await response.json();
}

type ChubChatParams = {
  readonly nocache?: number | undefined;
  readonly include_messages?: boolean | undefined;
  readonly include_config?: boolean | undefined;
  readonly include_meta?: boolean | undefined;
};

type ChubChatId = number & {
  readonly __type: "ChubChatId";
};

type ChubChatMessageId = number & {
  readonly __type: "ChubChatMessageId";
};

type IsoDateString = string & {
  readonly __type: "IsoDateString";
};

type ChubChatMessage = {
  readonly id: ChubChatMessageId;
  // TODO: is this correct?
  readonly speaker_id: ChubCardId | ChubUserId;
  readonly message: string;
  readonly parent_id: null | ChubChatMessageId;
  readonly extensions: Record<string, unknown>;
  readonly chat_id: number; // ChubChatId
  readonly created_at: IsoDateString;
  readonly is_bot: boolean;
  readonly is_main: boolean;
  readonly child_ids: readonly ChubChatMessageId[];
  readonly color: string; // Hex color code
  readonly model_id: string | null; // Model identifier
  readonly originator: string | null; // Originator identifier
};

type ChubChatResponse = {
  readonly chat: null | unknown;
  readonly roots: readonly ChubChatMessageId[];
  readonly starts: readonly ChubChatMessageId[];
  readonly leaves: readonly ChubChatMessageId[];
  readonly chatMessages: Record<ChubChatMessageId, ChubChatMessage>;
  readonly config: null | unknown;
};

export async function chubGetChat(
  chatId: ChubChatId,
  params: ChubChatParams = {},
): Promise<ChubChatResponse> {
  const query = new URLSearchParams(
    filterOutUndefined({
      nocache: Math.random().toString(),
      ...params,
    }) as unknown as Record<string, string>,
  ).toString();
  const response = await fetch(`${API_URL}/core/chats/v2/${chatId}?${query}`);
  return await response.json();
}

type ChubModelId = number & {
  readonly __type: "ChubModelId";
};

// TODO: test
type ChubChatMessageRequestCreate = {};
// TODO: test
type ChubChatMessageRequestDelete = {};
/** Optional fields are typically visible on a model message update. */
type ChubChatMessageRequestUpdate = {
  readonly id: ChubChatMessageId; // ID of the message to update
  readonly message: string; // New message content
  readonly color?: string; // Hex color code for the message
  readonly is_main?: boolean; // Whether to set this message as main
  readonly model_id?: ChubModelId; // Model identifier for the message
  readonly extensions?: Record<string, unknown>; // Optional extensions for the message
};

type ChubChatMessageRequest = {
  readonly create_ids: readonly ChubChatMessageRequestCreate[];
  readonly delete_ids: readonly ChubChatMessageRequestDelete[];
  readonly main_ids?: readonly ChubChatMessageId[]; // IDs to set as main messages
  readonly unmain_ids?: readonly ChubChatMessageId[]; // IDs to unset as main messages
  readonly update_ids?: readonly ChubChatMessageRequestUpdate[]; // Updates to existing messages
};

/** Optional fields are typically visible on a model message update. */
type ChubChatMessageResponseUpdate = {
  readonly short_id: UUID;
  readonly id: ChubChatMessageId;
  readonly message: string;
  readonly color?: string; // Hex color code
  readonly is_main: boolean;
  readonly model_id?: ChubModelId; // Model identifier
  readonly extensions?: Record<string, unknown>;
};

type ChubChatMessageResponseCreate = {
  readonly model: string; // Model identifier
  readonly message_uuid: null | UUID; // UUID for the message
  readonly api: "mercury" | "mars"; // API type
  readonly id: ChubChatMessageId;
  readonly is_bot: boolean;
  readonly extensions: Record<string, unknown>;
  readonly is_main: boolean;
  readonly message: string;
  readonly speaker_id: ChubCardId | ChubUserId; // Speaker identifier
  readonly parent_id: null | ChubChatMessageId; // Parent message ID
};

// TODO: test deleting a message
type ChubChatMessageResponseDelete = {};

type ChubChatAtomicMessageResponse = {
  readonly short_id: UUID;
  readonly create_ids: readonly ChubChatMessageResponseCreate[];
  readonly update_ids: readonly ChubChatMessageResponseUpdate[];
  readonly delete_ids: readonly ChubChatMessageResponseDelete[];
};

export async function chubPostAtomicMessage(
  chatId: ChubChatId,
  message: ChubChatMessageRequest,
): Promise<ChubChatAtomicMessageResponse> {
  const response = await fetch(
    `${API_URL}/core/chats/v2/${chatId}/messages/atomic`,
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(message),
    },
  );
  return await response.json();
}

export interface ChubPrompt {
  readonly template: string;
  readonly frequency_penalty: number;
  readonly max_tokens: number;
  readonly min_tokens: number;
  readonly model: string;
  readonly n_tokens: number;
  readonly presence_penalty: number;
  readonly token_repetition_penalty: number;
  readonly stop: readonly string[];
  readonly stream: boolean;
  readonly temperature: number;
  readonly top_p: number;
  readonly top_k: number;
}

export async function chubSetPrompt(prompt: ChubPrompt): Promise<void> {
  await fetch(`${API_URL}/prompt`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(prompt),
  });
}

export type ChubCommitId = UUID & {
  readonly __type2: "ChubCommitId";
};

export interface ChubCommit {
  readonly id: ChubCommitId;
  readonly short_id: string;
  readonly created_at: IsoDateString;
  readonly parent_ids: readonly UUID[];
  readonly title: string;
  readonly message: string;
  readonly committed_date: IsoDateString;
}

export type ChubFilePath = "raw/tavern_raw.json";
export const CHUB_TAVERN_FILE_PATH: ChubFilePath = "raw/tavern_raw.json";

export async function chubListCommits(
  projectId: ChubCardId,
  filePath: ChubFilePath = CHUB_TAVERN_FILE_PATH,
): Promise<readonly ChubCommit[]> {
  const params = new URLSearchParams({
    path: filePath,
    nocache: Math.random().toString(),
  }).toString();
  const response = await fetch(
    `${API_URL}/v4/projects/${projectId}/repository/commits?${params}`,
  );
  return await response.json();
}

export async function chubGetTavernCardAtCommit(
  projectId: ChubCardId,
  commitId: ChubCommitId,
): Promise<TavernCardV2> {
  const params = new URLSearchParams({
    ref: commitId,
    response_type: "blob",
  }).toString();
  const response = await fetch(
    `${API_URL}/v4/projects/${projectId}/repository/files/${encodeURIComponent(
      encodeURIComponent(CHUB_TAVERN_FILE_PATH),
    )}/raw?${params}`,
  );
  return await response.json();
}
